# Architecture



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# MVC

# Model Classes
	PaintModel
	PaintLayer

# View Classes
    View
	PaintPanel
	ShapeChooserPanel
	TextEditorDialog
	ColorPickerPopup
	LayerChooserPanel
	ToolbarPanel
	ZoomPanel

# Controller Classes
    View
	PaintPanel
	ShapeChooserPanel
	LayerChooserController
	ToolbarController
	ZoomController
	ZoomSliderController

# Layer Classes (classes that pertain to our layer feature)
    AddLayerCommand
    ChangeLayerCommand
    ChangeLayerVisibilityCommand
    DeleteLayerCommand
    LayerChooserController
    LayerChooserPanel
    PaintLayer
    PaintPanel

# Drawing Mode Classes (classes that pertain to drawing modes)
    Circle
    CircleStrategy
    Oval
    OvalStrategy
    Point
    Polyline
    PolylineStrategy
    Rectangle
    RectangleStrategy
    Shape
    ShapeFactory
    ShapeStrategy
    Square
    SquareStrategy
    Squiggle
    SquiggleStrategy
    StrategyFactory
    Text
    TextEditorDialog
    TextStrategy
    Triangle
    TriangleStrategy

# Tool Classes (classes that pertain to tools the user can use)
    ColorPickupPopup
    LineThicknessSlider
    PrecisionEraser
    PrecisionEraserStrategy
    ResizableCanvas
    SelectionTool
    SelectionToolStrategy
    StatusbarPanel
    Tool
    ToolbarController
    ToolbarPanel
    ZoomController
    ZoomSliderController

# File Menu Classes (classes that pertain to the file menu)
    Command
    CommandHistory
    FileHandlePopup
    FileHandler
    PatternParser

# Edit Menu Classes (classes that pertain to the edit menu)
    Command
    CommandHistory
    SelectionTool
    SelectionToolStrategy
    DeleteSelectedCommand
    DragCommand
    PasteCommand



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# Design Patterns Used (collections of classes into DP)

--------------------------------------------------------------------------------
Name: Shape Strategy
Pattern Name: Strategy
Reference: https://www.oodesign.com/images/design_patterns/behavioral/strategy_implementation_-_uml_class_diagram.gif

Purpose:
	The Strategy pattern was implemented to align with the Open-Closed Principle.
    In our application, each Shape (e.g. Circle, Rectangle) responds to mouse actions.
    In particular, they respond to mouse clicks, drags, and releases to register that
    they are being drawn onto the canvas. However, every Shape responds to these mouse
    actions in different ways. For example, for a Circle, the first mouse click represents
    the center of the Circle being drawn. However, for a Rectangle, the first mouse click
    represents the top left corner of the Rectangle being drawn. Therefore, the Strategy pattern
    allows us to create different strategies for different shapes, so that they can respond to
    the user as needed. This approach ensures that our program is open for extension and
    closed for modification: We can create new shape strategies and allow the context to decide
    which one needs to be implemented (in this application, the context would be which shape button
    the user clicked), instead of modifying the current existing code to use a new strategy.
    As a result, this design keeps the application flexible and scalable.

UML:
	(UML will be made after we put things into folders).

Classes:
	ShapeStrategy: Strategy Interface
	CircleStrategy: ConcreteStrategy
    OvalStrategy: ConcreteStrategy
    PolylineStrategy: ConcreteStrategy
    PrecisionEraserStrategy: ConcreteStrategy
    RectangleStrategy: ConcreteStrategy
    SelectionToolStrategy: ConcreteStrategy
    SquareStrategy: ConcreteStrategy
    SquiggleStrategy: ConcreteStrategy
    StrokeEraserStrategy: ConcreteStrategy
    TextStrategy: ConcreteStrategy
    TriangleStrategy: ConcreteStrategy
	StrategyFactory: Context

Usage:
	A developer would use this part of the code if they wanted to add a new shape
    strategy to the application. Firstly, they would need to create a new shape strategy
    that implements the ShapeStrategy interface. Then, they would need to ensure the context,
    which in our application is the StrategyFactory class, will use this new strategy
    when desired.
    (Note: How this last step is accomplished is discussed in the "Strategy Factory"
    section below).
--------------------------------------------------------------------------------
Name: Strategy Factory
Pattern Name: Factory
Reference: https://www.oodesign.com/images/stories/factory%20implementation.gif

Purpose:
    (Note: For more context behind what a strategy is in our application, please
    read the section "Shape Strategy" above).
	The Factory pattern was implemented to align with the Open-Closed Principle.
    In our application, the StrategyFactory is responsible for creating shape
    strategies (e.g., CircleStrategy, RectangleStrategy) based on which shape the
    user wants to draw. So, when the user clicks a button to choose a shape, that
    shape type is passed to the StrategyFactory, which then instantiates the correct
    shape strategy. This approach ensures that our program is open for extension and
    closed for modification: We can add new shape features by creating new shape strategies
    and updating the factory, instead of modifying the current existing code to support
    the new shape feature. As a result, this design keeps the application flexible and scalable.

UML:
	(UML will be made after we put things into folders).

Classes:
	StrategyFactory: Factory
    ShapeStrategy: Product Interface
    CircleStrategy: ConcreteProduct
    OvalStrategy: ConcreteProduct
    PolylineStrategy: ConcreteProduct
    PrecisionEraserStrategy: ConcreteProduct
    RectangleStrategy: ConcreteProduct
    SelectionToolStrategy: ConcreteProduct
    SquareStrategy: ConcreteProduct
    SquiggleStrategy: ConcreteProduct
    TextStrategy: ConcreteProduct
    TriangleStrategy: ConcreteProduct

Usage:
	A developer would use this part of the code if they wanted to add a new shape
    feature to the application. Firstly, they would need to create a new shape strategy
    that implements the ShapeStrategy interface. Then, they would need to update StrategyFactory
    to create this new strategy, by creating a new case corresponding to the shape's name
    (e.g. HexagonStrategy would have a case "hexagon").
--------------------------------------------------------------------------------
Name: Shape Factory
Pattern Name: Factory
Reference: https://www.oodesign.com/images/stories/factory%20implementation.gif

Purpose:
    The Factory pattern was implemented to align with the Open-Closed Principle.
    In our application, the ShapeFactory is responsible for creating shape
    objects (e.g., Circle, Rectangle) based on which type the user desires.
    So, when the user clicks a button to choose a shape, that shape type is passed to
    the ShapeFactory, which then instantiates the correct shape object.
    This approach ensures that our program is open for extension and closed for modification:
    We can add new shape features by creating new shape classes and updating the factory,
    instead of modifying the current existing code to support the new shape feature.
    As a result, this design keeps the application flexible and scalable.

UML:
	(UML will be made after we put things into folders).

Classes:
	ShapeFactory: Factory
	Shape: Product Interface
	Circle: ConcreteProduct
	Oval: ConcreteProduct
	Polyline: ConcreteProduct
	PrecisionEraser: ConcreteProduct
	Rectangle: ConcreteProduct
	Square: ConcreteProduct
	Squiggle: ConcreteProduct
	Text: ConcreteProduct
	Triangle: ConcreteProduct

Usage:
    A developer would use this part of the code if they wanted to add a new shape
    feature to the application. Firstly, they would need to create a new shape class
    that implements the Shape interface. Then, they would need to update ShapeFactory
    to create this new shape, by creating a new case corresponding to the shape's name
    (e.g. Hexagon would have a case "hexagon").
--------------------------------------------------------------------------------
Name: User Action Command
Pattern Name: Command
Reference: https://www.oodesign.com/images/design_patterns/behavioral/command_implementation_-_uml_class_diagram.gif

Purpose:
	The Command pattern was implemented to align with the Single Responsibility Principle.
	In our application, in order to support the Undo/Redo feature we have, we need to keep
	track of all user actions performed (so that we can later know which action to undo/redo).
	Each command class we have (e.g. AddLayerCommand, AddShapeCommand) only has one responsibility,
	which is to handle one specific action. This ensures our code is clear, modular, and manageable.
	The Command pattern also supports the Open-Close Principle, as creating a new command only
	requires creating a new command class and doesn't need to modify any existing code. As a result,
	this design also keeps the application flexible and scalable.

UML:
	(UML will be made after we put things into folders).

Classes:
	Command: Command
	AddLayerCommand: ConcreteCommand
	AddShapeCommand: ConcreteCommand
	ChangeLayerCommand: ConcreteCommand
	ChangeLayerVisibilityCommand: ConcreteCommand
	DeleteLayerCommand: ConcreteCommand
	DeleteSelectedCommand: ConcreteCommand
	DragCommand: ConcreteCommand
	PasteCommand: ConcreteCommand
	StrokeEraserCommand: ConcreteCommand
	PasteCommand: ConcreteCommand
	CommandHistory: Invoker
	PaintModel: Client
	PaintModel: Receiver

Usage:
    A developer would use this part of the code if they implement any new user action that
    requires undo/redo functionality. First, they would create a new command class and implement
    any methods that the command needs to be able to execute. Then, they need to modify the client
    class PaintModel to request this new command when necessary. Additionally, when PaintModel
    requests the new command, the new command should be passed in to the invoker CommandHistory.
    No adjustments to CommandHistory is needed. Lastly, the new command will be executed in sequence
    within the command queue in CommandHistory.
--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# High Level Architecture Discussion

	(Put all of the above together in a collection of stories which tell the
	developer how to modify, extend, or understand your code)

	(For each story, pull from and modify the highLevelTemplate.txt)

HOW TO MODIFY OUR CODE
--------------------------------------------------------------------------------
Name: New Drawing Mode
Description:
    A drawing mode enables a user to draw an object onto the screen, which could
    be a shape (e.g. Circle) or other elements (e.g. Text). ***The
	drawing mode consists of an image icon appearing in the left button panel.
	When the user clicks the image icon, the drawing mode is enabled. This means
	that a strategy for handling user input for this drawing mode is installed.***

	At this point, all mouse events in ...

Implementation:
	To add a new drawing mode X, provide the following:

	***image icon: Create a jpg image with dimensions 128x128, and place it
		on display in the Button Panel, placed in Assets/ButtonIconX.jpg
		(any special discussion...)***

    X:
    	    This is the shape class named X. This class should implement the Shape interface,
    	and have all the attributes required to draw the new shape. For example, it could
    	have an attribute Point center that corresponds to the shape's center when drawn.
    	    Furthermore, since the current application has the option to change the color of
        shapes, this new shape should support that feature. There is also an additional optional
        fill style feature, where the user can choose to draw a solid or outlined shape. The new
        shape could support these options if appropriate. For example, the Squiggle tool does not
        include a solid/outline option, as it is not applicable to this type of drawing.
    	    By our naming conventions, if the color and fill style features are implemented,
    	their attribute names should be as such:
            - Color color (default is Color.BLACK)
            - String fillStyle ("Solid"/"Outline", default is "Solid")
            - double lineThickness (ranges from 1.0 to 10.0, default is 1.0)
            In addition to these customization features, a new shape should be compatible with
        the stroke eraser. The logic of collision detection between the stroke eraser and
        the shape is implemented inside the overlaps(Tool tool) method. This can be achieved either
        by leveraging existing methods in JavaFX or by using mathematical equations.
            Another requirement for a new shape is to provide a String representation, allowing the
        instructions for drawing the shape to be saved in a Paint file, so that it can be reloaded
        when the user opens the file again. The String representation is provided by overloading
        the toString() method. By convention, the String representation should follow a format like this:
            "X{" + [Point(s) related to the shape, the shape's dimension, other info about the shape's display]
            + "," + this.color.toString() + "," + this.fillStyle + "," + this.lineThickness + "}";
        Moreover, the shape needs to be able to use this String representation to redraw itself.
        This is the purpose of the setShape(String[] data) method, where the String representation is passed in,
        and the shape sets all of its attributes accordingly.
            Lastly, a new shape should be compatible with the selection tool. In our application, this
        means that the shape should be able to be shifted around the canvas when selected by the
        selection tool. This logic is implemented in the shift(double x, double y) method. This simply
        requires shifting all Point objects of the shape by invoking the shift method on each Point.
        Additionally, the selection tool requires that the shape be able to be copied and pasted. This means
        that we need to be able to create a duplicate of the new shape, which is the purpose of the copy()
        method. This method should create a new instance of the shape, set all its attributes to match the
        original, and then return the new instance.

	XStrategy:
	        XStrategy must handle three mouse events: left mouse press, left mouse drag, and left mouse release.
	    The left mouse press marks the start of a new shape's creation, the left mouse drag adjusts the shape's size,
	    and the left mouse release finalizes the shape. XStrategy should also take in PaintPanel as a parameter, so
	    that shape X can be displayed onto the canvas when those mouse events occur. By convention, the PaintPanel
	    attribute is named panel.
	        When a left mouse press occurs, which corresponds to the method mousePressed(MouseEvent mouseEvent),
	    a new shape X is created using the ShapeFactory from PaintPanel. The newly created shape X is then set as the current
	    shape within PaintPanel. This step is crucial because PaintModel, responsible for notifying the view to display shapes
	    on the canvas, needs to know the shape type from PaintPanel. Next, using the position of the mouse press, shape X's
	    position is set accordingly. For example, it could represent the center of shape X or the top left corner of shape X.
	    Lastly, the shape X is added to the PaintModel, which adds and renders the user-drawn shape X onto the canvas.
	        When a left mouse drag occurs, which corresponds to the method mouseDragged(MouseEvent mouseEvent),
        the current shape X being drawn is retrieved from PaintPanel's current shape. It then updates its size and/or position
        according to the new mouse coordinates. Lastly, the previous version of shape X is removed from the PaintModel, and the
        updated version is added in its place.
            When a left mouse release occurs, which corresponds to the method mouseReleased(MouseEvent mouseEvent),
        the current shape X being drawn is retrieved from PaintPanel's current shape. The final update for its size
        and/or position are performed based on the position of the left mouse release. Once again, the previous version of shape
        X is removed from the PaintModel, and the final updated version is added in its place. Lastly, the current shape in PaintModel
        is set to null, indicating that drawing has been completed for shape X and no shape is currently being drawn anymore.

	ShapeFactory:
	    Include a new case for the new shape X. By convention, it should be
	        case "X" -> new X(fillStyle, lineThickness);
	    where fillStyle and lineThickness are optional parameters passed in,
	    depending on whether the shape X supports those features (as discussed above in
	    section X).

	StrategyFactory:
        Include a new case for the new shape X. By convention, it should be
            case "X" -> new XStrategy(panel);
        where panel is the PaintPanel.

Example:
	Square
	SquareStrategy
	ShapeFactory
	StrategyFactory
--------------------------------------------------------------------------------

HOW TO EXTEND OUR CODE
--------------------------------------------------------------------------------
Name: Resize Erasers
Description:
Possible implementation:
--------------------------------------------------------------------------------
Name: Dynamic Color Change for Drawn Shapes
Description:
Possible implementation:
--------------------------------------------------------------------------------

HOW TO UNDERSTAND OUR CODE
Stroke Eraser, Precision Eraser, Fill Style Selector, Line Thickness Selector, Magnifier Tool, Color Selector, Layer Support, File Menu, Text Editor, Undo/Redo, Resizable Canvas, Selection Tool, Cut/Copy/Paste/Delete
--------------------------------------------------------------------------------
Name: Stroke Eraser
Description:
Classes Involved:
Implementation:
--------------------------------------------------------------------------------