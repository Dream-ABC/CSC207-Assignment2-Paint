# Architecture

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# MVC

# Model Classes
	PaintModel
	PaintLayer

# View Classes
    View
	PaintPanel
	ShapeChooserPanel
	TextEditorDialog
	ColorPickerPopup
	LayerChooserPanel
	ToolbarPanel
	ZoomPanel

# Controller Classes
    View
	PaintPanel
	ShapeChooserPanel
	LayerChooserController
	ToolbarController
	ZoomController
	ZoomSliderController

# Layer Classes (classes that pertain to our layer feature)
    AddLayerCommand
    ChangeLayerCommand
    ChangeLayerVisibilityCommand
    DeleteLayerCommand
    LayerChooserController
    LayerChooserPanel
    PaintLayer
    PaintPanel

# Drawing Mode Classes (classes that pertain to drawing modes)
    Circle
    CircleStrategy
    Oval
    OvalStrategy
    Point
    Polyline
    PolylineStrategy
    Rectangle
    RectangleStrategy
    Shape
    ShapeFactory
    ShapeStrategy
    Square
    SquareStrategy
    Squiggle
    SquiggleStrategy
    StrategyFactory
    Text
    TextEditorDialog
    TextStrategy
    Triangle
    TriangleStrategy

# Tool Classes (classes that pertain to tools the user can use)
    ColorPickupPopup
    LineThicknessSlider
    PrecisionEraser
    PrecisionEraserStrategy
    ResizableCanvas
    SelectionTool
    SelectionToolStrategy
    StatusbarPanel
    Tool
    ToolbarController
    ToolbarPanel
    ZoomController
    ZoomSliderController

# File Classes (classes that pertain to the file menu)
    Command
    CommandHistory
    FileHandlePopup
    FileHandler
    PatternParser

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# Design Patterns Used (collections of classes into DP)

--------------------------------------------------------------------------------
Name: Shape Strategy
Pattern Name: Strategy
Reference: https://www.oodesign.com/images/design_patterns/behavioral/strategy_implementation_-_uml_class_diagram.gif

Purpose:
	The Strategy pattern was implemented to align with the Open-Closed Principle.
    In our application, each Shape (e.g. Circle, Rectangle) responds to mouse actions.
    In particular, they respond to mouse clicks, drags, and releases to register that
    they are being drawn onto the canvas. However, every Shape responds to these mouse
    actions in different ways. For example, for a Circle, the first mouse click represents
    the center of the Circle being drawn. However, for a Rectangle, the first mouse click
    represents the top left corner of the Rectangle being drawn. Therefore, the Strategy pattern
    allows us to create different strategies for different shapes, so that they can respond to
    the user as needed. This approach ensures that our program is open for extension and
    closed for modification: We can create new shape strategies and allow the context to decide
    which one needs to be implemented (in this application, the context would be which shape button
    the user clicked), instead of modifying the current existing code to use a new strategy.
    As a result, this design keeps the application flexible and scalable.

UML:
	(UML will be made after we put things into folders).

Classes:
	ShapeStrategy: Strategy Interface
	CircleStrategy: ConcreteStrategy
    OvalStrategy: ConcreteStrategy
    PolylineStrategy: ConcreteStrategy
    PrecisionEraserStrategy: ConcreteStrategy
    RectangleStrategy: ConcreteStrategy
    SelectionToolStrategy: ConcreteStrategy
    SquareStrategy: ConcreteStrategy
    SquiggleStrategy: ConcreteStrategy
    TextStrategy: ConcreteStrategy
    TriangleStrategy: ConcreteStrategy
	StrategyFactory: Context

Usage:
	A developer would use this part of the code if they wanted to add a new shape
    strategy to the application. Firstly, they would need to create a new shape strategy
    that implements the ShapeStrategy interface. Then, they would need to ensure the context,
    which in our application is the StrategyFactory class, will use this new strategy
    when desired.
    (Note: How this last step is accomplished is discussed in the "Strategy Factory"
    section below).

--------------------------------------------------------------------------------
Name: Strategy Factory
Pattern Name: Factory
Reference: https://www.oodesign.com/images/stories/factory%20implementation.gif

Purpose:
    (Note: For more context behind what a strategy is in our application, please
    read the section "Shape Strategy" above).
	The Factory pattern was implemented to align with the Open-Closed Principle.
    In our application, the StrategyFactory is responsible for creating shape
    strategies (e.g., CircleStrategy, RectangleStrategy) based on which shape the
    user wants to draw. So, when the user clicks a button to choose a shape, that
    shape type is passed to the StrategyFactory, which then instantiates the correct
    shape strategy. This approach ensures that our program is open for extension and
    closed for modification: We can add new shape features by creating new shape strategies
    and updating the factory, instead of modifying the current existing code to support
    the new shape feature. As a result, this design keeps the application flexible and scalable.

UML:
	(UML will be made after we put things into folders).

Classes:
	StrategyFactory: Factory
    ShapeStrategy: Product Interface
    CircleStrategy: ConcreteProduct
    OvalStrategy: ConcreteProduct
    PolylineStrategy: ConcreteProduct
    PrecisionEraserStrategy: ConcreteProduct
    RectangleStrategy: ConcreteProduct
    SelectionToolStrategy: ConcreteProduct
    SquareStrategy: ConcreteProduct
    SquiggleStrategy: ConcreteProduct
    TextStrategy: ConcreteProduct
    TriangleStrategy: ConcreteProduct

Usage:
	A developer would use this part of the code if they wanted to add a new shape
    feature to the application. Firstly, they would need to create a new shape strategy
    that implements the ShapeStrategy interface. Then, they would need to update StrategyFactory
    to create this new strategy, by creating a new case corresponding to the shape's name
    (e.g. HexagonStrategy would have a case "hexagon").

--------------------------------------------------------------------------------
Name: Shape Factory
Pattern Name: Factory
Reference: https://www.oodesign.com/images/stories/factory%20implementation.gif

Purpose:
    The Factory pattern was implemented to align with the Open-Closed Principle.
    In our application, the ShapeFactory is responsible for creating shape
    objects (e.g., Circle, Rectangle) based on which type the user desires.
    So, when the user clicks a button to choose a shape, that shape type is passed to
    the ShapeFactory, which then instantiates the correct shape object.
    This approach ensures that our program is open for extension and closed for modification:
    We can add new shape features by creating new shape classes and updating the factory,
    instead of modifying the current existing code to support the new shape feature.
    As a result, this design keeps the application flexible and scalable.

UML:
	(UML will be made after we put things into folders).

Classes:
	ShapeFactory: Factory
	Shape: Product Interface
	Circle: ConcreteProduct
	Oval: ConcreteProduct
	Polyline: ConcreteProduct
	PrecisionEraser: ConcreteProduct
	Rectangle: ConcreteProduct
	Square: ConcreteProduct
	Squiggle: ConcreteProduct
	Text: ConcreteProduct
	Triangle: ConcreteProduct

Usage:
    A developer would use this part of the code if they wanted to add a new shape
    feature to the application. Firstly, they would need to create a new shape class
    that implements the Shape interface. Then, they would need to update ShapeFactory
    to create this new shape, by creating a new case corresponding to the shape's name
    (e.g. Hexagon would have a case "hexagon").

--------------------------------------------------------------------------------
Name: User Action Command
Pattern Name: Command
Reference: https://www.oodesign.com/images/design_patterns/behavioral/command_implementation_-_uml_class_diagram.gif

Purpose:
	The Command pattern was implemented to align with the Single Responsibility Principle.
	In our application, in order to support the Undo/Redo feature we have, we need to keep
	track of all user actions performed (so that we can later know which action to undo/redo).
	Each command class we have (e.g. AddLayerCommand, AddShapeCommand) only has one responsibility,
	which is to handle one specific action. This ensures our code is clear, modular, and manageable.
	The Command pattern also supports the Open-Close Principle, as creating a new command only
	requires creating a new command class and doesn't need to modify any existing code. As a result,
	this design also keeps the application flexible and scalable.

UML:
	(UML will be made after we put things into folders).

Classes:
	Command: Command
	AddLayerCommand: ConcreteCommand
	AddShapeCommand: ConcreteCommand
	ChangeLayerCommand: ConcreteCommand
	ChangeLayerVisibilityCommand: ConcreteCommand
	DeleteLayerCommand: ConcreteCommand
	StrokeEraserCommandCommand: ConcreteCommand
	CommandHistory: Invoker
	PaintModel: Client
	PaintModel: Receiver

Usage:
    A developer would use this part of the code if they implement any new user action that
    requires undo/redo functionality. First, they would create a new command class and implement
    any methods that the command needs to be able to execute. Then, they need to modify the client
    class PaintModel to request this new command when necessary. Additionally, when PaintModel
    requests the new command, the new command should be passed in to the invoker CommandHistory.
    No adjustments to CommandHistory is needed. Lastly, the new command will be executed in sequence
    within the command queue in CommandHistory.

--------------------------------------------------------------------------------



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
# High Level Architecture Discussion

	(Put all of the above together in a collection of stories which tell the
	developer how to modify, extend, or understand your code)

	(For each story, pull from and modify the highLevelTemplate.txt)

HOW TO MODIFY OUR CODE
--------------------------------------------------------------------------------
New Drawing Mode
Description:
    A drawing mode enables a user to draw an object onto the screen, which could
    be a shape (e.g. Circle) or other elements (e.g. Text). ***The
	drawing mode consists of an image icon appearing in the left button panel.
	When the user clicks the image icon, the drawing mode is enabled. This means
	that a strategy for handling user input for this drawing mode is installed.***

	At this point, all mouse events in ...

Implementation:
	(inventory of ideas, required files, how they are tied to the architecture,
		naming conventions (example: images/ButtonIconSquare.jpg, MHStrategySquare, ShapeSquare...)

	To add a new drawing mode X, provide the following:

	***image icon: Create a jpg image with dimensions 128x128, and place it
		on display in the Button Panel, placed in Assets/ButtonIconX.jpg
		(any special discussion...)***

    X:
    	This is the shape class named X. This class should implement the Shape interface,
    	and have all the attributes required to draw the new shape. For example, it could
    	have a center point that corresponds to the user's first mouse click. The shape is
    	then drawn centered at that point. Furthermore, since the
    	current application has the option to draw solid or outlined shapes, as well as
    	change the color of shapes, this new drawing should support those features as well.
    	By our naming convention, there should be at Color color;
                                                      private String fillStyle;
                                                      private double lineThickness;
    	mode should
    	describing the attributes of the new shape as well as how it is drawn...
    		(any special discussion...)

	XStrategy:
		describing how user events are used to build the PaintModel...
		(any special discussion...)


Example:
	(for example, a list of files involved in the implementation of the Square drawing mode)
--------------------------------------------------------------------------------

HOW TO EXTEND OUR CODE
Cut, copy, paste

HOW TO UNDERSTAND OUR CODE
All extra features