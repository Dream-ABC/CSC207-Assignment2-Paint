# Architecture



----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
# MVC

# Model Classes
	PaintModel
	PaintLayer

# View Classes
    View
	PaintPanel
	ShapeChooserPopUp
	TextEditorDialog
	ColorPickerPopup
	LayerChooserPanel
	ToolbarPanel
	ToolChooserPopUp
	ZoomPanel

# Controller Classes
    View
	PaintPanel
	ShapeChooserPopUp
	LayerChooserController
	ToolbarController
	ZoomController
	ZoomSliderController

# Layer Classes (classes that pertain to our layer feature)
    AddLayerCommand
    ChangeLayerCommand
    ChangeLayerVisibilityCommand
    DeleteLayerCommand
    LayerChooserController
    LayerChooserPanel
    PaintLayer
    PaintPanel

# Drawing Mode Classes (classes that pertain to drawing modes)
    Circle
    CircleStrategy
    Oval
    OvalStrategy
    Point
    Polyline
    PolylineStrategy
    Rectangle
    RectangleStrategy
    Shape
    ShapeFactory
    ShapeStrategy
    Square
    SquareStrategy
    Squiggle
    SquiggleStrategy
    StrategyFactory
    Text
    TextEditorDialog
    TextStrategy
    Triangle
    TriangleStrategy

# Tool Classes (classes that pertain to tools the user can use)
    ColorPickupPopup
    LineThicknessSlider
    PrecisionEraser
    PrecisionEraserStrategy
    ResizableCanvas
    SelectionTool
    SelectionToolStrategy
    StatusbarPanel
    Tool
    ToolbarController
    ToolbarPanel
    ZoomController
    ZoomSliderController

# File Menu Classes (classes that pertain to the file menu)
    Command
    CommandHistory
    FileHandlePopup
    FileHandler
    PatternParser

# Edit Menu Classes (classes that pertain to the edit menu)
    Command
    CommandHistory
    SelectionTool
    SelectionToolStrategy
    DeleteSelectedCommand
    DragCommand
    PasteCommand



----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
# Design Patterns Used (collections of classes into DP)

----------------------------------------------------------------------------------------------------------
Name: Observer - LayerChooserController, ZoomPanel, StatusbarPanel, ResizableCanvas
      Observable - PaintModel
Pattern Name: Observer/Observable
Reference: https://www.oodesign.com/images/design_patterns/behavioral/observer_implementation_-_uml_class_diagram.gif

Purpose:
	(why is this pattern implemented? think SOLID as possible reasons and explain in terms of the application)

UML:
    ObserverObservableUML.png

Classes:
	LayerChooserController: Observer
	ZoomPanel: Observer
	StatusbarPanel: Observer
	ResizableCanvas: Observer

Usage:
	(Briefly describe why a developer would be playing with this part of
	the code and how they would use it to achieve that purpose)

----------------------------------------------------------------------------------------------------------
Name: Shape Strategy
Pattern Name: Strategy
Reference: https://www.oodesign.com/images/design_patterns/behavioral/strategy_implementation_-_uml_class_diagram.gif

Purpose:
	The Strategy pattern was implemented to align with the Open-Closed Principle. In our application,
	each Shape (e.g., Circle, Rectangle) responds to mouse actions. In particular, they respond to mouse
	clicks, drags, and releases to register that they are being drawn onto the canvas. However, every
	Shape responds to these mouse actions in different ways. For example, for a Circle, the first mouse
	click represents the center of the Circle being drawn. However, for a Rectangle, the first mouse click
    represents the top left corner of the Rectangle being drawn. Therefore, the Strategy pattern allows us
    to create different strategies for different shapes, so that they can respond to the user as needed.
    This approach ensures that our program is open for extension and closed for modification; We can
    create new shape strategies and allow the context to decide which one needs to be implemented (in this
    application, the context would be which shape button the user clicked), instead of modifying the
    current existing code to use a new strategy. As a result, this design keeps the application flexible
    and scalable.

UML:
	ShapeStrategyUML.png

Classes:
	ShapeStrategy: Strategy Interface
	CircleStrategy: ConcreteStrategy
    OvalStrategy: ConcreteStrategy
    PolylineStrategy: ConcreteStrategy
    PrecisionEraserStrategy: ConcreteStrategy
    RectangleStrategy: ConcreteStrategy
    SelectionToolStrategy: ConcreteStrategy
    SquareStrategy: ConcreteStrategy
    SquiggleStrategy: ConcreteStrategy
    StrokeEraserStrategy: ConcreteStrategy
    TextStrategy: ConcreteStrategy
    TriangleStrategy: ConcreteStrategy
	StrategyFactory: Context

Usage:
	A developer would use this part of the code if they wanted to add a new shape strategy to the
	application. Firstly, they would need to create a new shape strategy that implements the ShapeStrategy
	interface. Then, they would need to ensure the context, which in our application is the
	StrategyFactory class, will use this new strategy when desired.
    (Note: How this last step is accomplished is discussed in the "Strategy Factory" section below).
----------------------------------------------------------------------------------------------------------
Name: Strategy Factory
Pattern Name: Factory
Reference: https://www.oodesign.com/images/stories/factory%20implementation.gif

Purpose:
    (Note: For more context behind what a strategy is in our application, please read the section "Shape
    Strategy" above).
	The Factory pattern was implemented to align with the Open-Closed Principle. In our application, the
	StrategyFactory is responsible for creating shape strategies (e.g., CircleStrategy, RectangleStrategy)
	based on which shape the user wants to draw. So, when the user clicks a button to choose a shape, that
    shape type is passed to the StrategyFactory, which then instantiates the correct shape strategy. This
    approach ensures that our program is open for extension and closed for modification: We can add new
    shape features by creating new shape strategies and updating the factory, instead of modifying the
    current existing code to support the new shape feature. As a result, this design keeps the application
    flexible and scalable.

UML:
	StrategyFactoryUML.png

Classes:
	StrategyFactory: Factory
    ShapeStrategy: Product Interface
    CircleStrategy: ConcreteProduct
    OvalStrategy: ConcreteProduct
    PolylineStrategy: ConcreteProduct
    PrecisionEraserStrategy: ConcreteProduct
    RectangleStrategy: ConcreteProduct
    SelectionToolStrategy: ConcreteProduct
    SquareStrategy: ConcreteProduct
    SquiggleStrategy: ConcreteProduct
    StrokeEraserStrategy: ConcreteProduct
    TextStrategy: ConcreteProduct
    TriangleStrategy: ConcreteProduct

Usage:
	A developer would use this part of the code if they wanted to add a new shape feature to the
	application. Firstly, they would need to create a new shape strategy that implements the ShapeStrategy
	interface. Then, they would need to update StrategyFactory to create this new strategy, by creating a
	new case corresponding to the shape's name (e.g., HexagonStrategy would have a case "hexagon").
----------------------------------------------------------------------------------------------------------
Name: Shape Factory
Pattern Name: Factory
Reference: https://www.oodesign.com/images/stories/factory%20implementation.gif

Purpose:
    The Factory pattern was implemented to align with the Open-Closed Principle. In our application, the
    ShapeFactory is responsible for creating shape objects (e.g., Circle, Rectangle) based on which type
    the user desires. So, when the user clicks a button to choose a shape, that shape type is passed to
    the ShapeFactory, which then instantiates the correct shape object. This approach ensures that our
    program is open for extension and closed for modification; We can add new shape features by creating
    new shape classes and updating the factory, instead of modifying the current existing code to support
    the new shape feature. As a result, this design keeps the application flexible and scalable.

UML:
	ShapeFactoryUML.png

Classes:
	ShapeFactory: Factory
	Shape: Product Interface
	Circle: ConcreteProduct
	Oval: ConcreteProduct
	Polyline: ConcreteProduct
	PrecisionEraser: ConcreteProduct
	Rectangle: ConcreteProduct
	Square: ConcreteProduct
	Squiggle: ConcreteProduct
	Text: ConcreteProduct
	Triangle: ConcreteProduct

Usage:
    A developer would use this part of the code if they wanted to add a new shape feature to the
    application. Firstly, they would need to create a new shape class that implements the Shape interface.
    Then, they would need to update ShapeFactory to create this new shape, by creating a new case
    corresponding to the shape's name (e.g., Hexagon would have a case "hexagon").
----------------------------------------------------------------------------------------------------------
Name: User Action Command
Pattern Name: Command
Reference: https://www.oodesign.com/images/design_patterns/behavioral/command_implementation_-_uml_class_diagram.gif

Purpose:
	The Command pattern was implemented to align with the Single Responsibility Principle. In our
	application, in order to support the Undo/Redo feature we have, we need to keep track of all user
	actions performed (so that we can later know which action to undo/redo). Each command class we have
	(e.g., AddLayerCommand, AddShapeCommand) only has one responsibility, which is to handle one specific
	action. This ensures our code is clear, modular, and manageable. The Command pattern also supports the
	Open-Close Principle, as creating a new command only requires creating a new command class and doesn't
	need to modify any existing code. As a result, this design also keeps the application flexible and
	scalable.

UML:
	UserActionCommandUML.png

Classes:
	Command: Command
	AddLayerCommand: ConcreteCommand
	AddShapeCommand: ConcreteCommand
	ChangeLayerCommand: ConcreteCommand
	ChangeLayerVisibilityCommand: ConcreteCommand
	DeleteLayerCommand: ConcreteCommand
	DeleteSelectedCommand: ConcreteCommand
	DragCommand: ConcreteCommand
	PasteCommand: ConcreteCommand
	StrokeEraserCommand: ConcreteCommand
	CommandHistory: Invoker
	PaintModel: Client
	PaintModel: Receiver

Usage:
    A developer would use this part of the code if they implement any new user action that requires
    undo/redo functionality. First, they would create a new command class and implement any methods that
    the command needs to be able to execute. Then, they need to modify the client class PaintModel to
    request this new command when necessary. Additionally, when PaintModel requests the new command, the
    new command should be passed in to the invoker CommandHistory. No adjustments to CommandHistory is
    needed. Lastly, the new command will be executed in sequence within the command queue in CommandHistory.
----------------------------------------------------------------------------------------------------------



----------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------
# High Level Architecture Discussion

HOW TO MODIFY OUR CODE
----------------------------------------------------------------------------------------------------------
Name: New Drawing Mode

Description:
        A drawing mode enables a user to draw an object onto the screen, which could be a shape (e.g., Circle)
    or other elements (e.g., Text). The drawing mode consists of an image icon appearing in the shape
    button panel's pop-up menu. When the user clicks the image icon, the drawing mode is enabled. This
    means that the corresponding strategy for handling user input for this drawing mode is installed.
	    At this point, the mouse events press, drag, and release will affect the drawing of the new drawing
	mode. In particular, the mouse press should begin drawing, mouse drag should affect the size of the drawing
	(e.g., for a Circle, drag increases or decreases its radius), and mouse release should finalize the drawing.

Implementation:
	To add a new drawing mode X, provide the following:

	Image icon:
	        Create a png image with dimensions 18x18 that corresponds to the new drawing mode. Place this
	      image in Assets/theme-light/XTool.png and Assets/theme-dark/XTool.png (light mode and dark mode
	      for Paint). Then, display this icon in the ShapeChooserPopUp class.

    X:
    	    This is the shape class named X. This class should implement the Shape interface, and have all
    	the attributes required to draw the new shape. For example, it could have an attribute Point center
    	that corresponds to the shape's center when drawn.
    	    Furthermore, since the current application has the option to change the color of shapes, this
    	new shape should support that feature. There is also an additional optional fill style feature,
    	where the user can choose to draw a solid or outlined shape. The new shape could support these
    	options if appropriate. For example, the Squiggle tool does not include a solid/outline option,
    	as it is not applicable to this type of drawing.
    	    By our naming conventions, if the color and fill style features are implemented, their
    	attribute names should be as such:
            - Color color (default is Color.BLACK)
            - String fillStyle ("Solid"/"Outline", default is "Solid")
            - double lineThickness (ranges from 1.0 to 10.0, default is 1.0)
            In addition to these customization features, a new shape should be compatible with the stroke
        eraser. The logic of collision detection between the stroke eraser and the shape is implemented
        inside the overlaps(Tool tool) method. This can be achieved either by leveraging existing methods
        in JavaFX or by using mathematical equations.
            Another requirement for a new shape is to provide a String representation, allowing the
        instructions for drawing the shape to be saved in a Paint file, so that it can be reloaded when
        the user opens the file again. The String representation is provided by overloading the toString()
        method. By convention, the String representation should follow a format like this:
            "X{" + [Point(s) related to the shape, the shape's dimension, other info about the shape's display]
            + "," + this.color.toString() + "," + this.fillStyle + "," + this.lineThickness + "}";
        Moreover, the shape needs to be able to use this String representation to redraw itself. This is
        the purpose of the setShape(String[] data) method, where the String representation is passed in,
        and the shape sets all of its attributes accordingly.
            Lastly, a new shape should be compatible with the selection tool. In our application, this
        means that the shape should be able to be shifted around the canvas when selected by the
        selection tool. This logic is implemented in the shift(double x, double y) method. This simply
        requires shifting all Point objects of the shape by invoking the shift method on each Point.
        Additionally, the selection tool requires that the shape be able to be copied and pasted. This
        means that we need to be able to create a duplicate of the new shape, which is the purpose of the
        copy() method. This method should create a new instance of the shape, set all its attributes to
        match the original, and then return the new instance.

	XStrategy:
	        XStrategy must handle three mouse events: left mouse press, left mouse drag, and left mouse
	    release. The left mouse press marks the start of a new shape's creation, the left mouse drag adjusts
	    the shape's size, and the left mouse release finalizes the shape. XStrategy should also take in
	    PaintPanel as a parameter, so that shape X can be displayed onto the canvas when those mouse events
	    occur. By convention, the PaintPanel attribute is named panel.
	        When a left mouse press occurs, which corresponds to the method mousePressed(MouseEvent mouseEvent),
	    a new shape X is created using the ShapeFactory from PaintPanel. The newly created shape X is then
	    set as the current shape within PaintPanel. This step is crucial because PaintModel, responsible for
	    notifying the view to display shapes on the canvas, needs to know the shape type from PaintPanel.
	    Next, using the position of the mouse press, shape X's position is set accordingly. For example, it
	    could represent the center of shape X or the top left corner of shape X. Lastly, the shape X is
	    added to the PaintModel, which adds and renders the user-drawn shape X onto the canvas.
	        When a left mouse drag occurs, which corresponds to the method mouseDragged(MouseEvent mouseEvent),
        the current shape X being drawn is retrieved from PaintPanel's current shape. It then updates its
        size and/or position according to the new mouse coordinates. Lastly, the previous version of shape X
        is removed from the PaintModel, and the updated version is added in its place.
            When a left mouse release occurs, which corresponds to the method mouseReleased(MouseEvent mouseEvent),
        the current shape X being drawn is retrieved from PaintPanel's current shape. The final update for
        its size and/or position are performed based on the position of the left mouse release. Once again,
        the previous version of shape X is removed from the PaintModel, and the final updated version is
        added in its place. Lastly, the current shape in PaintModel is set to null, indicating that drawing
        has been completed for shape X and no shape is currently being drawn anymore.

	ShapeFactory:
	    Include a new case for the new shape X. By convention, it should be
	        case "X" -> new X(fillStyle, lineThickness);
	    where fillStyle and lineThickness are optional parameters passed in, depending on whether the shape X
	    supports those features (as discussed above in section X).

	StrategyFactory:
        Include a new case for the new shape X. By convention, it should be
            case "X" -> new XStrategy(panel);
        where panel is the PaintPanel.

Example:
	Square
	SquareStrategy
	ShapeFactory
	StrategyFactory
----------------------------------------------------------------------------------------------------------

HOW TO EXTEND OUR CODE
----------------------------------------------------------------------------------------------------------
Name: New Slider - Resizable Erasers (Stroke and Precision)

Description:
    Resizable erasers would allow users to adjust the eraser size, providing greater customization over
    the canvas and erasing process. This feature could be implemented for both the stroke eraser and the
    precision eraser. One possible implementation of this feature is to have a slider pop-up when the
    user clicks on an eraser button. The slider value then corresponds to the eraser's size, which could
    be any range desired.

Implementation:
    The specific implementation approach for this feature discussed above, is outlined below.

    [Type]EraserSizeSlider:
        A slider class could be created for both the stroke type and precision type eraser. This class
        would need to create the Slider object, display the pop-up onto the PaintPanel when appropriate,
        and register when the Slider object's value has changed.
            First, the slider class should extend Slider and implement ChangeListener, in order to support
        the creation of the slider object and to be able to register when the slider's value has changed.
            Next, the slider class should include a PaintPanel panel attribute, as the panel will be
        responsible for displaying the slider in the program. This attribute will be initialized inside
        the constructor, which will have a parameter for the PaintPanel.
            Then, there should be a show() method within the slider class, which will create the pop-up
        and display it onto the PaintPanel.
            Lastly, an overridden changed() method should be implemented to automatically adjust the
        eraser’s size based on the slider’s value.

Example:
    LineThicknessSlider - example of an implementation for [Type]EraserSizeSlider
----------------------------------------------------------------------------------------------------------
Name: New Tool - Dynamic Color Change for Drawn Shapes

Description:
        Dynamic color change would enable users to modify the color of their shapes even after the shapes
    have been drawn and finalized (i.e., after the user releases their mouse). This would increase
    customization options in the Paint program, enhancing the user experience. One possible implementation
    of this feature is to create a new "Color Change" button. When the user presses this button, they can
    select a color to apply to a shape. An icon will then appear at the mouse cursor, allowing the user to
    click on a shape to change its color to the selected option.

Implementation:
    The specific implementation approach for this feature discussed above, is outlined below.

    Image icon:
            Create a png image with dimensions 18x18 that corresponds to this color change tool. Place this
        image in Assets/theme-light/XTool.png and Assets/theme-dark/XTool.png (light mode and dark mode
        for Paint). Then, display this icon in the ToolChooserPopUp class.

    ColorChangeTool:
            A new tool is required to implement this feature, which could be named as
        ColorChangeTool. ColorChangeTool will implement the Tool interface. As a result, the attributes
        and methods required for this tool would include:
            - the top left point which indicates where the icon will be displayed, usually in relation
              to the user's mouse location
            - the dimensions of the tool, such as length and width
            - a display(GraphicsContext g2d) method, to draw the icon onto the canvas and make it
              visible to the user
        There should also be a Color color attribute, to store which color the user desires to change into.

    ColorChangePopup:
            To allow the user to select a new color, we can create a new class that extends Popup,
        which will create a ColorPicker and display it onto the PaintPanel. The color chosen
        would then be saved within the ColorChangeTool's color attribute.

    ColorChangeToolStrategy:
            For a new tool to function, it needs to have a corresponding strategy class. In this case, it
        could be named ColorChangeToolStrategy. This new strategy class would need to support mouse clicks,
        and register whenever it clicks on a Shape. Fortunately, the current code for Shapes already supports
        collision detection, so this will simply be an overlap(Tool tool) method call on each of the existing
        shapes in the current canvas. If there is an overlap, the shape's color will be changed to the
        ColorChange's color, which can be accomplished by calling the setColor(Color color) method.

Example:
    SelectionTool, StrokeEraser - examples of implementations for ColorChangeTool
    ColorPickerPopup - example of an implementation for ColorChangePopup
    SelectionToolStrategy, StrokeEraserStrategy - examples of implementations for ColorChangeToolStrategy
----------------------------------------------------------------------------------------------------------

HOW TO UNDERSTAND OUR CODE
Magnifier Tool, Color Selector, Layer Support, File Menu, Text Editor, Undo/Redo, Resizable Canvas, Selection Tool, Cut/Copy/Paste/Delete
----------------------------------------------------------------------------------------------------------
Name: Stroke Eraser

Description:
        The stroke eraser removes an entire stroke at once. For example, when the user draws a circle,
    using the stroke eraser will erase the entire circle at once. Note that for text, the stroke eraser
    erases the entire text, not one letter at a time.
        Within this program, the stroke eraser is represented as a black dashed square of size 14,
    centered at the mouse cursor.
        The stroke eraser is displayed as an image icon in the tool's pop-up panel. When the user clicks
    on the icon, the stroke eraser mode is activated, and a corresponding strategy for handling user mouse
    input is applied. The stroke eraser strategy ensures that when the stroke eraser is clicked or dragged
    across a shape, it removes the entire stroke of that shape from the canvas.

Classes/Interfaces Involved:
    Tool
    StrokeEraser
    ShapeStrategy
    StrokeEraserStrategy
    All Shape classes (e.g., Circle, Rectangle)
    PaintPanel

Implementation:
    Below is the implementation of the stroke eraser in this application.

    Image icon:
            The icon for stroke eraser is found in Assets/theme-light/StrokeEraserTool.png and
        Assets/theme-dark/StrokeEraserTool.png (light mode and dark mode for Paint). The icon is then
        displayed in the ToolChooserPopUp class.

    StrokeEraser:
            StrokeEraser implements the Tool interface. As a result, the attributes and methods required
        for this tool would include:
            - the top left point of the stroke eraser's square representation
            - the dimensions of the tool, which would be the size of the square
            - a display(GraphicsContext g2d) method, to draw the stroke eraser's representation onto
              the canvas and make it visible to the user, centered at the mouse cursor
        Overall, for the implementation of the stroke eraser, the StrokeEraser class is simply responsible
        for displaying its representation onto the canvas, PaintPanel.

    StrokeEraserStrategy:
            StrokeEraserStrategy implements the ShapeStrategy interface and handles the mouse press, mouse
        drag, and mouse release actions for the stroke eraser tool. When the user performs a left mouse
        press with the stroke eraser, the eraser starts the process of removing drawings. The eraser also
        adds itself to the PaintPanel, so that the stroke eraser is rendered on the canvas.
        This process
        continues on as the stroke eraser is dragged around. The erasing process only ends once the user
        has released their left mouse button.
            The logic for determining when to erase drawings, specifically the collision detection between
        the stroke eraser and the drawn shape, is implemented in the overlap(Tool tool) method within each
        shape class. The approach differs for each shape, as each has its own unique geometry.
            Overall, the StrokeEraserStrategy class detects when a stroke eraser collides with a shape,
        and removes them from the canvas accordingly.
----------------------------------------------------------------------------------------------------------
Name: Precision Eraser

Description:
        The precision eraser allows the user to erase specific segments of a drawing for finer detailing.
    It erases in the shape of a square. However, the precision eraser is implemented in a particular way;
    it doesn't erase by removing the shape. Instead, it draws transparent squares wherever it moves,
    creating the illusion of erasing.
        Within this program, the precision eraser is represented as a black dashed square of size 14,
    centered at the mouse cursor.
        The precision eraser is displayed as an image icon in the tool's pop-up panel. When the user
    clicks on the icon, the precision eraser mode is activated, and a corresponding strategy for handling
    user mouse input is applied. The precision eraser strategy ensures that the user has the customizability
    and flexibility to erase specific aspects of a drawing.

Classes/Interfaces Involved:
    Shape
    PrecisionEraser
    ShapeStrategy
    PrecisionEraserStrategy
    PaintPanel

Implementation:
    Below is the implementation of the precision eraser in this application.

    Image icon:
            The icon for stroke eraser is found in Assets/theme-light/PrecisionEraserTool.png and
        Assets/theme-dark/PrecisionEraserTool.png (light mode and dark mode for Paint). The icon is then
        displayed in the ToolChooserPopUp class.

    PrecisionEraser:
            PrecisionEraser implements the Shape interface. A key feature of the eraser's attributes is
        its color attribute, which determines its visual representation. While the user is still using
        the precision eraser, it is displayed as a black dashed square on the canvas. Once the user
        finishes using the eraser, the dashed square disappears by setting the color attribute to
        transparent, making it effectively invisible.
            PrecisionEraser is represented as a series of points, which is the path that the user drew
        when using the precision eraser. The transparent rectangles are drawn using those points as their
        centre.
            Overall, for the implementation of the precision eraser, the PrecisionEraser class is simply
        responsible for displaying its representation onto the canvas and drawing the transparent squares
        in PaintPanel.

    PrecisionEraserStrategy:
            PrecisionEraserStrategy implements the ShapeStrategy interface and handles the mouse press,
        mouse drag, and mouse release actions for the precision eraser tool. When the user performs a left
        mouse press with the precision eraser, the eraser starts the process of 'removing' drawings by
        drawing a transparent square that is the size of the eraser, located at the eraser's current location.
        This process continues on as the precision eraser is dragged around. The erasing process only ends
        once the user has released their left mouse button. As these transparent rectangles are drawn, they
        are stored as shapes in the PaintModel, which then renders them on the canvas.
----------------------------------------------------------------------------------------------------------
Name: Fill Style Selector

Description:
        The fill style selector allows users to choose whether they want to draw a solid shape or an
    outlined shape. This option does not apply to squiggles, polylines, or text.
        The fill style selector is found within the menu item "View". There is the option "Solid" to draw
    solid shapes, and "Outline" to draw outlined shapes.

Classes/Interfaces Involved:
    ShapeChooserPopUp
    PaintModel
    ShapeFactory
    View

Implementation:
    Below is the implementation of the fill style selector in this application.

    View:
            The menu bar created inside View, specifically the "View" option inside the menu bar, has fill
        style options presented in its drop-down bar.

    ShapeChooserPopUp:
            When the button for a fill style is clicked, either "Solid" or "Outline", the ShapeChooserPopUp
        sets PaintModel's fillStyle to be what the user selected.

    PaintModel:
            After PaintModel receives a new fill style, it notifies its Observer, PaintPanel, of the change.
        This allows PaintPanel to acquire the latest fillStyle required for creating new shapes, which it
        will then pass into ShapeFactory when the user begins drawing shapes.

    ShapeFactory:
        With the provided String fillStyle passed in as a parameter, the ShapeFactory can create the correct
        shape and fill style for any shape type.
----------------------------------------------------------------------------------------------------------
Name: Line Thickness Selector

Description:
        The line thickness selector allows users to choose how thick they want the outline of their shape
    to be. This option does not apply when users draw solid shapes.
        The line thickness selector is found within the menu item View -> Line Thickness. It is a Slider
    that ranges from 0-50, with the default value being 1. Once the user adjusts the Slider to their
    desired value, all outlined shapes in the application will have that selected line thickness value.

Classes/Interfaces Involved:
    View
    LineThicknessSlider
    PaintPanel
    ShapeFactory

Implementation:
    Below is the implementation of the line thickness selector in this application.

    View:
            View creates the menu bar, which inside the drop-down bar for "View", contains the item
        "Line Thickness". When the user clicks this menu item, the pop-up displaying the line thickness
        slider appears.

    LineThicknessSlider:
            LineThicknessSlider creates a Slider object, displays the pop-up screen onto the program when
        appropriate, and registers when the Slider object's value has changed. This is achieved by
        extending Slider and implementing ChangeListener, in order to support the creation of the slider
        object and to be able to register when the slider's value has changed.
            This class has a PaintPanel panel attribute, as the panel will be responsible for displaying
        the slider in the program. There is also a show() method within the slider class, which will
        create the pop-up screen and display it onto the PaintPanel. Lastly, there is an overridden
        changed() method that automatically sets line thickness value in PaintPanel, which then sets the
        line thickness value in PaintModel, based on the slider’s value. PaintPanel will then pass the
        line thickness value into ShapeFactory when the user begins drawing outlined shapes.

    ShapeFactory:
            With the provided double lineThickness passed in as a parameter, the ShapeFactory can create
        the correct shape and line thickness for any outlined shape type.
----------------------------------------------------------------------------------------------------------
Name: Color Selector

Description:
        The color selector allows users to select a color for drawing shapes.
        The color selector can be found in the menu item View -> Color Picker. Users can pick a color
    from a standard color palette or enter custom color values in various modes (HSB, RGB, or Hexadecimal).
    The color selector also allows users to adjust the opacity of the selected color, applying consistent
    color choices across all shapes in the application.

Classes/Interfaces Involved:
    View
    ColorPickerPopup
    PaintPanel

Implementation:
    Below is the implementation of the color picker in this application.

    View:
            View creates the menu item "Color". When the user clicks this menu item, the pop-up displaying
        the color picker appears.

    ColorPickerPopup:
            ColorPickerPopup creates a ColorPicker object and displays the pop-up screen on the program
        when appropriate. It listens for the color selection event and updates the selected color
        in the PaintPanel. The user can choose a color either by selecting from the default color palette
        or by entering custom color values in HSB, RGB, or Hex modes. This is achieved by extending
        the Popup class, allowing the creation of the color selector and handling the selection event.
            The ColorPickerPopup class uses JavaFX's built-in ColorPicker control and provides a
        display() method that creates and shows the color picker pop-up. This method also temporarily
        disables interactions on the PaintPanel to prevent unintended changes while the popup is active.
        Once the popup is closed, actions on the PaintPanel are re-enabled. The selected color and opacity
        are applied to all shapes drawn on the canvas.

    PaintPanel:
            PaintPanel listens for the color change events triggered by the ColorPickerPopup. When a color
        is selected, PaintPanel updates the current color used for drawing shapes, ensuring that
        the selected color is applied consistently across the canvas.
----------------------------------------------------------------------------------------------------------
Name: Text Editor

Description:
        The Text Editor allows users to add and edit text shapes on the canvas. It consists of an
    image icon in the left button panel. When users click on this icon, the text editing mode is activated.
    Users can then click anywhere on the canvas to place a text shape. A pop-up text editor dialog will
    appear, enabling users to choose the text's font and size from a scrolling menu. The dialog also provides
    toggle buttons to modify the text's style (bold, italic, underline, strikethrough). As users input or
    modify the text, it is dynamically rendered and updated on the canvas, providing a flexible and
    interactive experience for adding annotations or descriptions on the canvas.

Classes/Interfaces Involved:
    Shape
    Text
    TextEditorDialog
    ShapeStrategy
    TextStrategy
    PaintPanel

Implementation:
    Below is the implementation of the color picker in this application.

   Image icon:
            Create png images with dimensions 15x15 for the toggle buttons of bold, italic, underline,
        and strikethrough. These images should be displayed in the text editor pop-up screen and placed in
        the following locations:
            - "images/bold.png" for the bold button
            - "images/italic.png" for the italic button
            - "images/underline.png" for the underline button
            - "images/strikethrough.png" for the strikethrough button.

   Text:
            The Text class represents a text shape within the PaintPanel. It implements the Shape interface
        to ensure consistency with other shapes in the application.
            The class contains all the information necessary for a text shape, including the interactive
        text node, font, size, style (bold, italic, underline, strikethrough), color, and position. The
        Text class provides a set of getter and setter methods, which allow associated controllers (such
        as the TextEditorDialog) to retrieve and update these properties.

   TextEditorDialog:
            TextEditorDialog creates a Dialog object and displays the pop-up screen on the program whenappropriate.
        A TextEditorDialog object is bound with a specific Text object, meaning changes made in a dialog will
        only affect the associated Text shape. TextEditorDialog listens for the button selection events and
        updates the selected font for the specified text shape. It offers a display() method to open the pop-up,
        and a getSelectedFont() method to retrieve the user-selected font, ensuring that the customization is applied
        dynamically to the text shape on the canvas.

   TextStrategy:
            The TextStrategy class takes a Text shape and its corresponding TextEditorDialog, and manages mouse events
        (mousePressed, mouseDragged, and mouseReleased) to enable users to add and customize text on the current layer.
            Specifically, when the primary mouse button is released, TextStrategy prompts the user by displaying
        the TextEditorDialog, allowing them to set properties such as font, size, style, and color. Based on
        the user's input, TextStrategy updates the Text shape's appearance on the canvas in real-time, ensuring
        a smooth and interactive experience for text customization. Moreover, a Text shape is created only when
        the text content is not empty. In other words, the Text shape will be removed from the layer if there is
        no content in it.
----------------------------------------------------------------------------------------------------------
Name: Layer Support

Description:
            The layer support feature allows users to add and work on different layers. This feature can be used by
        clicking on the image icon stating "Layers" on the toolbar on the top of the paint panel.
            Users are able to add and remove different layers, switch between different layers to draw separate
        shapes. Users can also set any layers to invisible, so that it will not be shown without the need to delete the work.

Classes/Interfaces Involved:
    AddLayerCommand
    ChangeLayerCommand
    ChangeLayerVisibilityCommand
    DeleteLayerCommand
    LayerChooserController
    LayerChooserPanel
    PaintLayer
    Shape
    StrokeEraser
    SelectionTool
    PaintPanel
    PaintModel
    View

Implementation:
    Below is the implementation of the color picker in this application.

    Image icon:
            Each layer has an image icon presenting the thumbnail of the layer, providing users a more intuitive
        control over different layers, especially when the number of layers increases.

    AddLayerCommand:
            The AddLayerCommand class provides an execute() method to add a layer to the PaintPanel, and an undo() method
        to remove the added layer from the PaintPanel.

    ChangeLayerCommand:
            The ChangeLayerCommand class provides an execute() method to switch to a specific layer, and an undo() method
        to switch to the previous layer.

    ChangeLayerVisibilityCommand:
            The ChangeLayerVisibilityCommand class provides an execute() method to change a layer's visibility to visible
        or invisible, and an undo() method to change the layer's visibility to its previous state.

    DeleteLayerCommand:
            The DeleteLayerCommand class provides an execute() method to delete a specific layer from the PaintPanel,
        and an undo() method to add the deleted layer back to the PaintPanel in the original order.

    LayerChooserController:
            The LayerChooserController class enables users to switch between layers and manage the visualization of the
        image icons in the LayerChooserPanel. It observes changes in PaintModel and integrates with both PaintModel
        and LayerChooserPanel to provide control over layer selection and thumbnail visualization.
            The selectLayer() method allows users to change the currently selected layer in PaintModel, updating which
        layer receives drawing inputs and edits. The update() method refreshes the layer thumbnails displayed in
        LayerChooserPanel, ensuring that users see an accurate preview of each layer’s content. This design provides
        intuitive layer management, allowing users to organize and visually navigate complex drawings more easily.

    LayerChooserPanel:
            The LayerChooserPanel class manages the visual representation of layer image icons within the panel.
        It dynamically adds or removes icons in real-time as layers are created or deleted, ensuring that the panel
        accurately reflects the current state of all layers. The class also incorporates intuitive color labeling
        to distinguish different states: selected layers are highlighted, while invisible layers appear in a light grey color.
            The LayerChooserPanel class provides an updateAllLayers() method to update all layer image icons, and a handle()
        method to handle the action event triggered by the buttons in the LayerChooserPanel.

    PaintLayer:
            The PaintLayer class represents an individual layer within the drawing canvas, allowing for flexible layering
         of different shapes. Each PaintLayer can contain a unique set of shapes, an optional background image, a stroke eraser,
         and a selection tool for shape selection on individual layer. This structure enables users to independently draw, erase,
         and select shapes on separate layers, offering precise control and organization for each layer individually.
----------------------------------------------------------------------------------------------------------
Name: File Menu

Description:
            The File Menu provides options for users to load or save their projects as files. This feature is accessible
        under the "File" menu item.
            The "New" option discards all current progress, allowing the user to start with a new PaintPanel. The "Open"
        option enables users to open either a PNG file or a custom PAINT file based on their selection. Opening a PNG file
        sets it as the background of the currently selected layer, while opening a PAINT file restores the entire state of
        the project, including all previous actions, allowing users to undo actions unlimitedly. Note that when opening
        a PAINT file, all current progress will be discarded.
            The "Save" option lets users store their current work as either a PNG file or a custom PAINT file. Saving as a
        PNG captures a static image of the PaintPanel, while the PAINT file preserves the full project state in PaintPanel,
        including all shapes, layers, and undo/redo history for future editing.
            The "Exit" option closes the application without saving, allowing users to exit quickly if they do not need to
        store recent changes.

Classes/Interfaces Involved:
    FileHandlePopup
    FileHandler
    PatternParser
    PaintPanel
    PaintModel

Implementation:
    Below is the implementation of the line thickness selector in this application.

    View:
            View creates the file menu and displays it to the user when their mouse hovers over "File".

    FileHandlePopup:
            The FileHandlePopup class manages file operations in the PaintPanel, providing dialogs for opening, saving, and creating
        new files. It allows users to choose between PNG and PAINT file formats, handling the loading, saving, and resetting of
        the PaintPanel.
            To be more specific, the openFile() method opens a dialog that lets users choose a file type (either .png or .paint) to open.
        It then loads the corresponding file based on the user's selection; the saveFile() method displays a dialog that allows users
        to save their work as either a PNG file or a PAINT file, depending on the user's choice; the newFile() method prompts the user
        with a confirmation dialog to ensure they want to discard the current progress and start a new file. If confirmed, the PaintPanel
        is reset and a new file is initialized. The FileHandlePopup will call corresponding methods in FileHandler based on user's choices
        on opening or saving a file.

    FileHandler:
            The FileHandler class is responsible for handling file operations in the PaintPanel, including saving and opening PNG and PAINT files.
        It interacts with the PaintPanel to perform these actions. The saveImage() method allows the user to save the current layer as a PNG file,
        converting the PaintPanel content into a PNG image. The openImage() method enables the user to open a PNG file and set it as the background
        of the selected layer. The savePaint() method saves the whole PaintPanel as a PAINT file by writing the canvas size and drawing commands
        to the file, while openPaint() reads and executes the commands from a PAINT file using the PatternParser to restore the drawing state.

    PatternParser:
            The PatternParser class parses command strings from the loaded PAINT file and converts them into executable commands, which are then used to
        restore the user's previous drawing actions in the PaintPanel. The parseLine() method takes a line of command string and a PaintPanel as input,
        and processes the command to return an appropriate Command object, and manages changes in PaintPanel if needed. For each command type, the method
        extracts necessary data from the string, creates the corresponding command object, and returns it, enabling the restoration of the drawing state
        stored in a PAINT file.
----------------------------------------------------------------------------------------------------------
Name: Undo/Redo

Description:
            The Undo and Redo buttons allow any changes made to the canvas to be reverted or reapplied.
            The buttons can be found in the menu item Edit. Using these buttons the user is able to
         revert the following changes: adding a new shape, deleting shapes, dragging shapes, pasting
         copied shapes, adding or removing layers, switching layers, changing layer visibility.

Classes/Interfaces Involved:
    All Command Classes (e.g., AddShapeCommand, AddLayerCommand)
    CommandHistory
    Command
    PaintModel

Implementation:
    Below is the implementation of the Undo/Redo in this application.

    Command:
                The Command interface is implemented by all ConcreteCommand classes.
                This allows for any new command to have the execute, undo, and toString methods.
            These methods are mandatory to be able to undo or redo a change made to the canvas.

    CommandHistory:
                The CommandHistory is responsible for storing commands in two stacks, undoStack and
            redoStack. The undoStack stores any commands that are undoable, when undo is called, the
            top most command is popped from the stack is popped and undone. Then the command is
            pushed onto the redoStack.
                When a new command executes, the redoStack is cleared since these changes should not
            be run again.
                There are various other methods implemented for some commands which are only called
            by specific classes. Such as changes to shapes, such as StrokeEraser require the previous
            state of shapes to be stored such that it can be reverted back to when Undo is called.
            The addToLast method is used to pass in information to the StrokeEraserCommand regarding
            additional shapes that have been removed in the current stroke. the popLastCommand is used
            by DeleteLayerCommand to allow another undo to be run in the case that there is only 1
            remaining layer. Similarly, popLastRedoCommand is used by AddLayerCommand to deal with
            the case of the user trying to undo an AddLayerCommand when only one layer remains.

    PaintModel:
                The PaintModel is where the CommandHistory is instantiated and stored and is
            responsible for executing new commands and calling undo and redo methods on the
            CommandHistory.
----------------------------------------------------------------------------------------------------------
Name: Resizable Canvas

Description:
                The Resizable Canvas allows for the canvas to be resized using the buttons in the
            edges of the canvas. These buttons can be dragged to increase or decrease the size of
            the canvas.
                When resizing the canvas, the right buttons and bottom buttons match the mouse cursor
            position while the left and top buttons apply the change on the opposite side of the canvas.

Classes/Interfaces Involved:
    ResizableCanvas
    PaintPanel
    PaintModel
    View

Implementation:
    Below is the implementation of the Resizable Canvas in this application.

    ResizableCanvas:
                The ResizableCanvas extends the Pane, it is a custom Pane that holds the canvas,
            which is the PaintPanel and also the buttons used for the resizing.
                The ResizableCanvas is instantiated with a initial height and initial width
            which is set as the canvas width and height.
                There are 8 buttons created, one for every edge and vertex, created at size 6,
            and set to their respective positions. These buttons are setOnAction such that when
            the button is dragged, they cause an update on the size of the canvas, resizing
            depending on the direction that the mouse was moved towards.
                Since ResizableCanvas is an observer observing the paintModel, whenever their is an
            update in paintModel, the canvas updates to confirm that the size of the canvas, and
            the positions of the buttons are correct.
----------------------------------------------------------------------------------------------------------
Name: Selection Tool

Description:
                The selection tool allows for shapes to be selected on the selectedLayer and to be
            dragged when the mouse is clicked inside the bounds of an existing selection tool.
                The button is available on the top toolbar ribbon and can be drawn like any other
            shape on the canvas.
                When the selection tool is being dragged, any shapes previously selected before the
            user began dragging will also be dragged maintaining their relative position inside the
            selection tool.

Classes/Interfaces Involved:
    SelectionTool
    SelectionToolStrategy
    PaintModel
    PaintLayer
    PasteCommand
    DeleteSelectedCommand
    DragCommand
    All Shape classes (e.g. Circle, Rectangle)

Implementation:
    Below is the implementation of the Selection Tool in this application.


    SelectionTool:
            SelectionTool implements the Tool interface. As a result, the attributes and methods required
                    for this tool would include:
                        - the top left point of the selection tool's rectangle representation
                        - the dimensions of the tool
                        - a display(GraphicsContext g2d) method, to draw the selection tool similar to how
                            a rectangle would be drawn.
                    Overall, for the implementation of the selection tool, the SelectionTool class is simply
                    responsible for displaying its representation onto the canvas, PaintPanel and storing the
                    selected shapes.

    SelectionToolStrategy:
                The SelectionToolStrategy handles the mouse events to draw and drag the selection tool.
                When a mouse is pressed, if there exists a selection tool and the mouse is inside the
            bounds of the selection tool, then the program prepares for the selection to be dragged by
            creating a new DragCommand and setting the dragging as true. If there is no selection tool
            or the mouse is not inside the bounds, a new selection tool is created and added to the model.
                When the mouse is dragged, if dragging is set to true, the selection tool and selected shapes
            are shifted while updating the previously created DragCommand. If dragging is set to false, then
            the selection tool is drawn such that one of the vertices is at the the original placement and the
            opposite vertex is at the mouse cursor. Then selectShapes is run to select all of the shapes in the
            selected layer that have some part of the shape inside the bounds of the selection tool. To see if
            any part of the shape is inside the selection tool, the overlap method in the shape is used.
                When the mouse is released dragging is set to false.
    PaintModel:
                The paint model stores the current selection tool, it is used by other methods such as cut,
            copy, delete, paste.
----------------------------------------------------------------------------------------------------------
Name: Cut/Copy/Paste/Delete

Description:
                The Cut, Copy, Paste, and Delete buttons apply operations on the shapes selected
            by the Selection Tool.
                The buttons are available under the menu item Edit.
                Cut copies the selected shapes and deletes the selected shapes.
                Copy copied the selected shapes.
                Paste pastes the copied shapes onto the canvas shifted over.
                Delete deletes the selected shapes.

Classes/Interfaces Involved:
    SelectionTool
    PaintModel
    View
    Command
    PasteCommand
    DeleteSelectedCommand
    CommandHistory
    All Shape classes (e.g., Circle, Rectangle)

Implementation:
    Below is the implementation of the Undo/Redo in this application.

    SelectionTool:
                The SelectionTool is responsible for selecting the shapes such that the operations
            like copy and paste can be applied on the selected shapes.

    PaintModel:
                The PaintModel has the methods that are called when any of the buttons are clicked.
                For copy, there are two private attributes that stores a copy of the selectedShapes
            and the SelectionTool.
                For paste, a new PasteCommand is executed passing in the selected layer, the command
            history, the ArrayList of copied selected shapes, a copy of the selection tool and the
            paint model. The command is then executed making a copy of the shapes shifted from their
            old positions.
                For cut, the methods for copy and delete are called to recreate the effect of cut.
                For delete, a new DeleteSelectedCommand is executed passing in the selected layer,
            command history, and the ArrayList of shapes that are meant to be deleted.

    View:
                The view is responsible for creating the buttons and calling the methods in the
            paint model when the buttons are pressed.

    Command:
                PasteCommand and DeleteSelectedCommand implement the Command Interface.

    PasteCommand:
                When a new PasteCommand is created, the layer, command history, ArrayList of
            copied shapes, a copy of the selection tool, and the paint model are stored in
            private attributes.
                When the command is executed, a copy of the shapes are added to the layer,
            and the selection tool is updated to a copy of the stored selection tool. Both
            the selection tool and shapes are shifted over by 100 in both x and y directions
            to allow the user to easily see the new shapes.
                When the command is undone, the layer's shapes are reverted back to the old state
            before the command was executed.

    DeleteSelectedCommand:
                When a new DeleteSelectedCommand is created, the layer, command history, and the
            ArrayList of shapes to be deleted are stored in private attributes. In addition, the
            indexes of the shapes are stored in a separate ArrayList.
                When the command is executed, the state of shapes is stored and the shapes are
            deleted from the selected layer's ArrayList of shapes.
                When the command is undone, the state of the selected layer's shapes is reverted
            back to before the command was executed.

    CommandHistory:
                The CommandHistory is used to undo or redo the paste and delete commands and also
            the cut command since cut calls delete.
----------------------------------------------------------------------------------------------------------