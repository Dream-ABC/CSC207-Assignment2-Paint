# Please discuss your architectural decisions below.

High Level Architecture:

	MVC
	To keep the code simple, a partial MVC was implemented.
	
	Model
	The Model, PaintModel, captures enough information to re-draw the sketch of the user.
	PaintModel currently captures all the Points, Circles, Rectangles, and Paths.
	It notifies the View, PaintPanel, of any changes that occur.
	In particular, it notifies PaintPanel when a new Point/Circle/Rectangle/Path is added to the Model.
	
	View+Controller
	There is a View class as well as a few, what we call, view components.
	The View class containing the BorderPane as well as containing all of its components.
	View components are meant to be contained in the main View.
	Examples of view components are PaintPanel and ShapeChooserPanel.
	
	The View class, and view components all implements their own controller.
	For example, the PaintPanel listens to its own MouseEvents.
	This is instead of separating out the Controller from the View. This choice
	was made to simplify the code, yet still keep it modular and clear.
	
	Each view component can see the containing View as well as the Model
	as appropriate. This means that each view component can speak to the
	other view components. An example of this is when the ShapeChooserPanel
	buttons are clicked, resulting in a mode change in the PaintPanel.
	
---------------------------------------------------------------------
TODO!!! Add in more architecture and discussion. For example, 
do you do something interesting to fix the association between the 
ShapeChooser and the PaintPanel? How about the PaintModel, something
is clearly wrong with it. Can you come up with a better architecture?
---------------------------------------------------------------------

DESIGN PATTERNS USED
	TODO!!! If you introduce a Design Pattern to solve a problem, 
	discuss it below. Only add design patterns if they simplify and improve
	the code. I see at least two that would greatly improve code. 
		
	Strategy:
	Command: 
	Singleton:
	Composite:
	Factory:
	Builder:
	Observer/Observable: PaintModel - Observable, PaintPanel - Observer



OTHER ARCHITECTURE DISCUSSIONS
---------------------------------------------------------------------
---------------------------------------------------------------------
UNDERSTANDING OF THE CURRENT ORGANIZATION OF THE CODE

As discussed in section 'High Level Architecture', there is an MVC architecture in place.
The UML diagram (paint.uml) depict the relationships and interactions between the classes in this program.
The description below explains some of the key ideas of the current organization of the code:

PaintModel, which is the Model, is composed of shape classes (Circle, Point, Rectangle).
As the model, PaintModel manages the data for the Paint program.
The data, in this case, is the drawings that should be displayed on the view.
As an Observable, PaintModel notifies its observer (PaintPanel) whenever a new shape is created.
New shapes are appended to their corresponding PaintModel's ArrayList attribute,
through PaintModel's add[shapeName] method.

PaintPanel, which is one of the view components, is an Observer.
It observes the PaintModel and performs various actions, depending on the mouse event and mode
(mode refers to the user-selected shape to draw), through its handle method.
There are currently three shapes that can be drawn: Circle, Rectangle, and Path.
Each shape is described through a class (Circle class, Rectangle class, and Path is described through the Point class).
As seen in the UML diagram, each shape class have different attributes.
PaintPanel, which is composed of these shapes classes, use those attributes to accurately draw each shape
and display them on the view.

ShapeChooserPanel is another one of the view components.
It creates buttons and displays them onto the view for the user,
so that users can select which shape they want to draw.
Also, as discussed within the section 'High Level Architecture', ShapeChooserPanel can interact with PaintPanel.
Whenever a ShapeChooserPanel button is clicked (buttons correspond to drawing a Circle, Rectangle, or Path),
there is a corresponding mode change in the PaintPanel.

There is also a main View, which is the View class.
View contains the model (PaintModel) and view components (PaintPanel, ShapeChooserPanel).
It displays the view components onto the stage and updates the model as needed.
View also creates and displays a menu bar onto the stage.
ShapeChooserPanel interacts with PaintPanel through View.
Specifically, ShapeChooserPanel updates the mode attribute of PaintPanel, through the View's setMode method.
Also, note that view components implement their own controllers (as described in section 'High Level Architecture').

Paint is the application, and it connects the Model (PaintModel) and View + Controller (View) to itself.
This is where the stage for the program is, and where the program runs.

Shapes are composed of Points.
Circle's attribute centre is a Point, and Rectangle's attribute topLeft is a Point.
This is done to simplify how the (x,y) coordinates of a point are represented in code.
The Path shape is created using a starting Point and an ending Point.
---------------------------------------------------------------------
HOW TO EXTEND CURRENT CODE TO ADD ANOTHER SHAPE FEATURE

With the current code architecture,
adding a new shape features can be done by creating subclasses of the current shape classes available
(Circle, Rectangle, Point) or creating a new separate class.

PaintModel must be modified to include new attributes and methods for the new shape feature.
There will need to be a new ArrayList attribute for the shape, add[shapeName] method, and get[shapeName] method.

Also, ShapeChooserPanel will need a new button corresponding to the new shape, so that
users can indicate they want to draw the new shape.
This means ShapeChooserPanel's constructor must be modified to include the new button.
The new button's id will correspond to the PaintPanel's mode when drawing this new shape.

Moreover, PaintPanel's handle method needs to be updated with a new case "[shapeName]",
with code for what needs to occur when various mouse actions (e.g. press, drag, move, release) occur.
    - Mouse press should typically be the centre/anchor point of the new shape drawing (similar to how the
      first mouse press is the centre of a Circle, or the first mouse press is the top left of a Rectangle).
    - Mouse drag should display the shape in mid-construction, so that the user can see the shape they're
      about to build on release of the mouse button.
    - Mouse move currently has no function for any shapes
    - Mouse release should display the final shape drawn onto the canvas.
---------------------------------------------------------------------
ISSUES WITH THE CURRENT ARCHITECTURE

There exists an instance of tight coupling between ShapeChooserPanel, View and the PaintPanel. These three
modules are closely connected, as the ShapeChooserPanel directly calls View.setMode() to change the drawing
mode in the PaintPanel. This presents issues with maintainability as high dependency often requires modifications
to several files, as well as reusability since the modules are not independent and rely on others in order to work.